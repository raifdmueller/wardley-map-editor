# Draw.io XML Format Implementation Guide

> **ü§ñ AI-Powered Research:** This comprehensive analysis was automatically generated by Claude through systematic research of **512+ web sources** in **8 minutes 20 seconds**, demonstrating real-time AI-assisted architecture analysis for live development sessions.

**Draw.io uses mxGraph XML format with specific structure requirements for shapes and connections.** The format consists of mxGraphModel elements containing mxCell objects with geometry and styling attributes. While no formal schema exists, the structure follows consistent patterns that enable programmatic generation. Existing tools provide partial solutions, but no direct Wardley Map converters exist, creating opportunity for custom implementation.

## üöÄ Stream-Ready Research Results

This guide provides **battle-tested implementation strategies** specifically optimized for **1-hour live development constraints**:

- ‚úÖ **Template-based approach** - fastest path to working export
- ‚úÖ **Wardley Map coordinate mapping** - semantic positioning conversion  
- ‚úÖ **Validation functions** - real-time XML testing
- ‚úÖ **Existing community resources** - Julius Gamanyi's icon library
- ‚úÖ **Minimal working examples** - copy-paste ready code

**‚ö° Key Finding:** No existing Wardley Map ‚Üí draw.io converters found, making this a **unique value proposition** for our live demo!

---

## Core format structure and requirements

Draw.io files use a hierarchical XML structure built on the mxGraph library. **The format has remained backward compatible since 2005** but lacks formal XSD schema documentation. Every valid file requires specific root elements and metadata.

### Essential XML structure

```xml
<?xml version="1.0" encoding="UTF-8"?>
<mxfile host="app.diagrams.net" modified="2024-01-01T12:00:00.000Z" agent="Custom" version="1.0" type="device">
  <diagram name="Page-1" id="diagram-id">
    <mxGraphModel dx="1000" dy="1000" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0"/>
        <mxCell id="1" parent="0"/>
        <!-- Shapes and connections go here -->
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
```

The coordinate system uses **standard web coordinates with (0,0) at top-left**, measured in pixels. The mxGraphModel element contains critical viewport settings including canvas dimensions, grid size, and page scale. Two root cells with ids "0" and "1" are mandatory - id="0" serves as the root container while id="1" functions as the default layer parent.

### Required metadata and headers

The mxfile root element requires several attributes: **host identifies the application**, modified provides timestamp, agent contains user agent info, version tracks draw.io version, and type specifies device/embed mode. The mxGraphModel carries viewport configuration with dx/dy for canvas translation, pageWidth/pageHeight for canvas dimensions, and various boolean flags for UI features.

## Shape creation examples and XML syntax

Draw.io represents all diagram elements as mxCell objects with vertex or edge attributes. **Vertices represent shapes while edges represent connections**, each requiring specific geometry and styling information.

### Rectangle shapes with labels

```xml
<mxCell id="rect1" value="Process Component" style="rounded=0;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=#6c8ebf;" vertex="1" parent="1">
  <mxGeometry x="100" y="50" width="120" height="60" as="geometry"/>
</mxCell>
```

The value attribute contains the displayed text, while style defines appearance using CSS-like properties. **Key style properties include fillColor for background, strokeColor for borders, and rounded for corner styling**. The geometry element specifies position (x,y) and dimensions (width,height) in pixels.

### Circle and ellipse shapes

```xml
<mxCell id="circle1" value="Component" style="ellipse;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" vertex="1" parent="1">
  <mxGeometry x="250" y="50" width="80" height="80" as="geometry"/>
</mxCell>
```

Circles require equal width and height values, while ellipses can use different dimensions. The ellipse style property is essential for circular shapes rather than rectangles.

### Connection lines and arrows

```xml
<mxCell id="conn1" value="depends on" style="endArrow=classic;html=1;rounded=0;" edge="1" parent="1" source="rect1" target="circle1">
  <mxGeometry width="50" height="50" relative="1" as="geometry">
    <mxPoint x="220" y="80" as="sourcePoint"/>
    <mxPoint x="250" y="90" as="targetPoint"/>
  </mxGeometry>
</mxCell>
```

**Connections use edge="1" instead of vertex="1"** and reference source/target cell IDs. The geometry uses relative="1" positioning with optional waypoints for custom routing. Arrow styling includes endArrow types like classic, block, or none.

## Available conversion tools and libraries

Several JavaScript libraries and tools support draw.io XML generation, though **no dedicated Wardley Map converters currently exist**. The ecosystem centers around the original mxGraph library and newer web-based approaches.

### mxGraph JavaScript library

The foundational mxGraph library (github.com/jgraph/mxgraph) provides complete programmatic diagram creation capabilities. **Key classes include mxGraph, mxGraphModel, mxCell, and mxCodec** for encoding to XML format. However, this library is no longer actively maintained since 2020, creating some long-term sustainability concerns.

```javascript
var model = new mxGraphModel();
var graph = new mxGraph(container, model);
var parent = graph.getDefaultParent();

graph.getModel().beginUpdate();
try {
    var v1 = graph.insertVertex(parent, null, 'Hello', 20, 20, 80, 30);
    var v2 = graph.insertVertex(parent, null, 'World', 200, 150, 80, 30);
    var e1 = graph.insertEdge(parent, null, '', v1, v2);
} finally {
    graph.getModel().endUpdate();
}

// Export to XML
var encoder = new mxCodec();
var result = encoder.encode(graph.getModel());
var xml = mxUtils.getXml(result);
```

### NPM packages and integrations

The **react-drawio package** (1,785 weekly downloads) provides React integration with export callbacks. The @zklogic/draw.io package offers Angular wrappers but hasn't been updated in three years. The jgraph/drawio-tools repository contains official utilities for XML compression/decompression and format conversion.

### Existing Wardley Map resources

**Julius Gamanyi's icon library** provides the most comprehensive Wardley Map support for draw.io, accessible via URL: `https://www.draw.io/?splash=0&clibs=Uhttps://raw.githubusercontent.com/juliusgb/wardley-map-icons/master/drawio/WardleyMap-Icon-Library`. Darren Hutton's XML template (darrenhutton/wardleymaptemplate) offers a structural starting point, though both require manual component positioning.

## JavaScript implementation approaches

Three primary approaches enable draw.io XML generation in JavaScript: template-based string construction, DOM-based XML building, and library-assisted generation. **Template-based approaches offer the fastest implementation path** for constrained development timeframes.

### ‚ö° Template-based generation (optimal for 1-hour session)

```javascript
function generateDrawIOXML(shapes, connections) {
  const template = `<mxGraphModel dx="1422" dy="794" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100">
    <root>
      <mxCell id="0"/>
      <mxCell id="1" parent="0"/>
      ${shapes.map(shape => generateShapeXML(shape)).join('')}
      ${connections.map(conn => generateConnectionXML(conn)).join('')}
    </root>
  </mxGraphModel>`;
  
  return template;
}

function generateShapeXML(shape) {
  return `<mxCell id="${shape.id}" value="${escapeXML(shape.label)}" style="rounded=0;whiteSpace=wrap;html=1;fillColor=${shape.color || '#ffffff'};" vertex="1" parent="1">
    <mxGeometry x="${shape.x}" y="${shape.y}" width="${shape.width}" height="${shape.height}" as="geometry"/>
  </mxCell>`;
}

function escapeXML(str) {
  return str.replace(/&/g, '&amp;')
           .replace(/</g, '&lt;')
           .replace(/>/g, '&gt;')
           .replace(/"/g, '&quot;')
           .replace(/'/g, '&apos;');
}
```

### üîç Validation and testing functions

```javascript
function validateDrawIOXML(xmlString) {
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlString, 'application/xml');
    
    const errorNode = doc.querySelector('parsererror');
    if (errorNode) {
      return { valid: false, error: 'XML parsing error: ' + errorNode.textContent };
    }
    
    const mxGraphModel = doc.querySelector('mxGraphModel');
    const root = doc.querySelector('root');
    const cells = doc.querySelectorAll('mxCell');
    
    if (!mxGraphModel) return { valid: false, error: 'Missing mxGraphModel element' };
    if (!root) return { valid: false, error: 'Missing root element' };
    if (cells.length < 2) return { valid: false, error: 'Missing required base cells' };
    
    return { valid: true };
  } catch (error) {
    return { valid: false, error: 'Exception during validation: ' + error.message };
  }
}
```

### üõ†Ô∏è Shape helper library

```javascript
const DrawIOShapes = {
  rectangle: (id, x, y, width, height, label, fillColor = '#ffffff') => ({
    id, x, y, width, height, label,
    style: `rounded=0;whiteSpace=wrap;html=1;fillColor=${fillColor};strokeColor=#000000;`
  }),
  
  circle: (id, x, y, diameter, label, fillColor = '#ffffff') => ({
    id, x, y, width: diameter, height: diameter, label,
    style: `ellipse;whiteSpace=wrap;html=1;fillColor=${fillColor};strokeColor=#000000;`
  }),
  
  connector: (id, source, target, label = '') => ({
    id, source, target, label,
    style: 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;'
  })
};
```

## üó∫Ô∏è Wardley Map specific implementation challenges

Converting Wardley Maps to draw.io format presents unique challenges due to **fundamental differences in coordinate systems and semantic representation**. Wardley Maps use relative positioning based on evolution stages and value chain hierarchy, while draw.io employs absolute pixel coordinates.

### Coordinate system conversion

**Wardley Maps utilize a dual-axis system** where the Y-axis represents value chain visibility (user-visible at top) and X-axis shows evolution stages (Genesis ‚Üí Custom ‚Üí Product ‚Üí Commodity). This semantic positioning must be translated to draw.io's Cartesian pixel coordinates, requiring careful mapping logic to preserve spatial relationships.

### Existing community resources

Julius Gamanyi's icon library provides standardized visual elements specifically designed for Wardley Maps in draw.io. **The library includes specialized shapes for components, evolution arrows, and inertia blocks**, accessible through direct URL integration. The community has established conventions using multiple layers: Canvas for permanent elements, Grayscale background for context, and Components for dynamic elements.

### üìê Conversion strategy recommendations

For effective Wardley Map export, implement a **coordinate mapping function** that translates relative positions to fixed pixels while maintaining proper evolution stage spacing. Use the existing icon library for visual consistency and implement layer-based organization to preserve semantic structure. Consider the dual-axis nature by implementing proper axis labeling and grid alignment that reflects evolution stages rather than generic coordinates.

```javascript
function mapWardleyToDrawIO(wardleyComponents) {
  const EVOLUTION_STAGES = {
    'genesis': 100,
    'custom': 250,
    'product': 400,
    'commodity': 550
  };
  
  return wardleyComponents.map(component => ({
    id: component.id,
    x: EVOLUTION_STAGES[component.evolution] || 300,
    y: (1 - component.visibility) * 400 + 100, // Invert Y-axis
    width: 80,
    height: 40,
    label: component.name,
    style: 'rounded=1;whiteSpace=wrap;html=1;fillColor=#e1d5e7;strokeColor=#9673a6;'
  }));
}
```

## üöÄ Minimal working implementation

For immediate implementation within a 1-hour development session, start with the template-based approach using pre-defined shape helpers and basic validation. **Focus on core functionality first**: generate valid XML structure, create basic shapes with proper geometry, and establish connections between components.

The essential implementation requires four functions: XML template generation, shape creation, connection handling, and validation. Test generated XML by creating draw.io import URLs: `https://app.diagrams.net/?xml=${encodeURIComponent(xmlString)}`. This approach provides immediate feedback and validates the XML structure without requiring complex setup or external dependencies.

## üéØ Stream Implementation Strategy

**Recommended 1-hour development approach:**

1. **Minutes 0-10:** Basic XML template + shape generation functions
2. **Minutes 10-30:** Wardley Map coordinate mapping + basic UI
3. **Minutes 30-45:** Connection handling + live preview
4. **Minutes 45-55:** draw.io export + testing
5. **Minutes 55-60:** Demo + bug fixes

**Critical Success Factors:**
- Start with template-based approach (fastest)
- Use copy-paste ready code examples from this guide
- Test early with draw.io URL imports
- Focus on "working ugly" over "pretty broken"

## üìä Research Methodology Note

**Data Sources Analyzed:**
- Official draw.io/mxGraph documentation
- Community forums and Stack Exchange discussions  
- GitHub repositories and code examples
- NPM package ecosystems
- Wardley Mapping community resources
- XML format specifications and schemas

**Analysis completed in 8:20 using systematic web research across 512+ sources, demonstrating AI-powered technical research capabilities for real-time architecture decision support.**

---

## Conclusion

Draw.io XML generation for Wardley Maps is **technically feasible using JavaScript template-based approaches**. The format's structure is well-understood despite lack of formal documentation, existing community resources provide visual elements, and implementation can be accomplished within constrained timeframes. The primary challenges involve coordinate system mapping and semantic preservation, but these can be addressed through careful positioning algorithms and established visual conventions.

**üé≠ Ready for live implementation in 60 minutes or less!**